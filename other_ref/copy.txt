1 Appjs:

// /src/app.js
// -----------------------------------------------------------
// IMPORTS
// -----------------------------------------------------------
import { startListening, stopListening, stopSpeaking } from "./speech.js";
import { avatarStartTalking, avatarStopTalking } from "./threejs-avatar.js";

// Backend URL
const API_URL = "http://localhost:4000/api/chat";

// UI elements (guarding in case some are missing)
const micBtn = document.getElementById("micBtn");
const testBtn = document.getElementById("testBtn");
const clearBtn = document.getElementById("clearBtn");
const demoLessonBtn = document.getElementById("demoLessonBtn");

const pauseTtsBtn = document.getElementById("pauseTtsBtn");
const resumeTtsBtn = document.getElementById("resumeTtsBtn");
const stopTtsBtn = document.getElementById("stopTtsBtn");

const transcriptBox = document.getElementById("transcript");
const replyBox = document.getElementById("reply");
const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");

const schoolMode = document.getElementById("schoolMode");
const subject = document.getElementById("subject");

const classButtons = document.querySelectorAll(".class-btn");
const subjectButtons = document.querySelectorAll(".subject-btn");

const chatInput = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");
const conversationScroll = document.getElementById("conversationScroll");

let isListening = false;
let userWantedContinuous = false; // remember if user wants auto-resume after replies
let isTtsPaused = false;
let isSpeaking = false;
let lastUtterance = null;      // SpeechSynthesisUtterance object (if available)
let lastSpokenText = "";       // plain string of last text spoken (fallback)

// -----------------------------------------------------------
// LOGGING UTILITY
// -----------------------------------------------------------
function log(msg) {
  if (!logEl) {
    console.log("[log]", msg);
    return;
  }
  logEl.innerHTML += `‚Ä¢ ${msg}<br>`;
  logEl.scrollTop = logEl.scrollHeight;
}

// -----------------------------------------------------------
// Markdown rendering + TTS cleanup helper
// Requires `marked` and `DOMPurify` loaded (CDN added in index.html).
// If not available, falls back to plain text.
// -----------------------------------------------------------
function renderReplyMarkdown(markdownText) {
  const md = markdownText || "";
  const unsafeHtml = (typeof marked !== "undefined") ? marked.parse(md) : md;
  const safeHtml = (typeof DOMPurify !== "undefined") ? DOMPurify.sanitize(unsafeHtml, { ADD_ATTR: ["target"] }) : unsafeHtml;

  if (replyBox) {
    replyBox.innerHTML = safeHtml;
  }

  const temp = document.createElement("div");
  temp.innerHTML = safeHtml;
  let plainText = temp.textContent || temp.innerText || "";

  plainText = plainText
    .replace(/[*_]{1,3}/g, "")
    .replace(/#{1,6}\s+/g, "")
    .replace(/\[(.*?)\]\(.*?\)/g, "$1")
    .replace(/\s{2,}/g, " ")
    .trim();

  return plainText;
}

// -----------------------------------------------------------
// Auto-scroll helper (scroll conversation area to bottom)
// -----------------------------------------------------------
function scrollConversationToBottom(smooth = true) {
  if (!conversationScroll) return;
  try {
    if (smooth) conversationScroll.scrollTo({ top: conversationScroll.scrollHeight, behavior: "smooth" });
    else conversationScroll.scrollTop = conversationScroll.scrollHeight;
  } catch (e) {
    conversationScroll.scrollTop = conversationScroll.scrollHeight;
  }
}

// -----------------------------------------------------------
// Fallback TTS implementation (makes window.speakText available)
// Dispatches 'avatarTalkStart' and 'avatarTalkStop' events for avatar sync.
// If your speech.js already provides speakText/stopSpeaking that dispatches events,
// this fallback will not override it (we check first).
// -----------------------------------------------------------
if (typeof window.speakText !== "function") {
  window.speakText = function (text) {
    if (!text) return;
    lastSpokenText = text;

    if ("speechSynthesis" in window) {
      try {
        // cancel existing to avoid overlap
        window.speechSynthesis.cancel();
      } catch (e) { /* ignore */ }

      const ut = new SpeechSynthesisUtterance(text);
      ut.lang = "en-IN";

      ut.onstart = () => {
        isSpeaking = true;
        isTtsPaused = false;
        lastUtterance = ut;
        document.dispatchEvent(new CustomEvent("avatarTalkStart"));
        log("TTS started");
      };
      ut.onend = () => {
        isSpeaking = false;
        lastUtterance = null;
        document.dispatchEvent(new CustomEvent("avatarTalkStop"));
        log("TTS ended");
      };
      ut.onerror = (ev) => {
        isSpeaking = false;
        lastUtterance = null;
        document.dispatchEvent(new CustomEvent("avatarTalkStop"));
        console.warn("TTS error", ev);
      };

      // (Optional) choose a suitable voice
      const voices = window.speechSynthesis.getVoices();
      if (voices && voices.length) {
        ut.voice = voices.find(v => v.lang && v.lang.startsWith("en")) || voices[0];
      }

      try {
        window.speechSynthesis.speak(ut);
      } catch (e) {
        console.warn("speechSynthesis.speak failed", e);
      }
    } else {
      console.warn("No speechSynthesis available in this browser.");
    }
  };
}

// Provide stopSpeaking if not provided by speech.js
if (typeof stopSpeaking !== "function") {
  window.stopSpeaking = function () {
    if ("speechSynthesis" in window) {
      try {
        window.speechSynthesis.cancel();
        isTtsPaused = false;
        isSpeaking = false;
        lastUtterance = null;
        document.dispatchEvent(new CustomEvent("avatarTalkStop"));
        log("TTS cancelled via stopSpeaking()");
      } catch (e) {
        console.warn("stopSpeaking error", e);
      }
    }
  };
}

// -----------------------------------------------------------
// Helpers: TTS control (pause / resume / stop) using speechSynthesis
// improved resume logic using lastSpokenText fallback
// -----------------------------------------------------------
function setPauseResumeUI(paused) {
  if (pauseTtsBtn) pauseTtsBtn.style.display = paused ? "none" : "inline-block";
  if (resumeTtsBtn) resumeTtsBtn.style.display = paused ? "inline-block" : "none";
}

function pauseTTS() {
  if ("speechSynthesis" in window && window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
    try {
      window.speechSynthesis.pause();
      isTtsPaused = true;
      setPauseResumeUI(true);
      statusEl && (statusEl.textContent = "Paused (reading)");
      log("TTS paused");
      return;
    } catch (e) { console.warn("pauseTTS error", e); }
  }

  // If not speaking, still mark paused so resume knows to restart last text if needed
  isTtsPaused = true;
  setPauseResumeUI(true);
  statusEl && (statusEl.textContent = "Paused");
  log("TTS pause requested but engine not actively speaking; will restart on resume if needed.");
}

function resumeTTS() {
  // Case A: speechSynthesis present and reports paused -> resume
  if ("speechSynthesis" in window) {
    try {
      if (window.speechSynthesis.paused) {
        window.speechSynthesis.resume();
        isTtsPaused = false;
        setPauseResumeUI(false);
        statusEl && (statusEl.textContent = "Reading...");
        log("TTS resumed (resume())");
        return;
      }

      // If not paused but still speaking (maybe resumed already)
      if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
        isTtsPaused = false;
        setPauseResumeUI(false);
        statusEl && (statusEl.textContent = "Reading...");
        log("TTS already active; resume no-op");
        return;
      }

      // If not speaking (browser cleared utterance when paused), restart lastSpokenText
      if (!window.speechSynthesis.speaking) {
        if (lastSpokenText && lastSpokenText.trim()) {
          log("No active utterance to resume ‚Äî restarting last text.");
          // Kick off speakText which sets up new utterance and events
          try {
            // update UI
            setPauseResumeUI(false);
            statusEl && (statusEl.textContent = "Reading...");
            window.speakText(lastSpokenText);
            isTtsPaused = false;
          } catch (e) {
            console.warn("Error restarting lastSpokenText on resume:", e);
          }
          return;
        } else {
          log("No lastSpokenText available to restart on resume.");
        }
      }
    } catch (e) {
      console.warn("resumeTTS error:", e);
    }
  } else {
    // No speechSynthesis fallback: if we have lastSpokenText, restart via speakText
    if (lastSpokenText && lastSpokenText.trim()) {
      try {
        window.speakText(lastSpokenText);
        isTtsPaused = false;
        setPauseResumeUI(false);
        statusEl && (statusEl.textContent = "Reading...");
        log("TTS restarted via fallback speakText");
      } catch (e) {
        console.warn("resume fallback error", e);
      }
    } else {
      log("Resume unsupported and no last text found.");
    }
  }
}

function stopTTS() {
  try {
    if (typeof stopSpeaking === "function") stopSpeaking();
    else if (window.speechSynthesis) window.speechSynthesis.cancel();

    isTtsPaused = false;
    isSpeaking = false;
    lastUtterance = null;
    lastSpokenText = "";
    setPauseResumeUI(false);
    if (resumeTtsBtn) resumeTtsBtn.style.display = "none";
    statusEl && (statusEl.textContent = "Idle");
    log("TTS stopped");
  } catch (e) { console.warn("stopTTS error", e); }
}

// Attach to buttons (if present)
if (pauseTtsBtn) pauseTtsBtn.addEventListener("click", pauseTTS);
if (resumeTtsBtn) resumeTtsBtn.addEventListener("click", resumeTTS);
if (stopTtsBtn) stopTtsBtn.addEventListener("click", stopTTS);

// Keep speaking state in sync with avatar events (speech.js may also dispatch these)
document.addEventListener("avatarTalkStart", () => {
  isSpeaking = true;
  statusEl && (statusEl.textContent = "Reading...");
});
document.addEventListener("avatarTalkStop", () => {
  isSpeaking = false;
  // resume listening when appropriate (userWantedContinuous) - handled in askBackend flow
  if (!userWantedContinuous) {
    statusEl && (statusEl.textContent = "Idle");
  }
});

// -----------------------------------------------------------
// FORMAT PROMPT WITH SCHOOL MODE + SUBJECT (fine-tuned by grade)
// -----------------------------------------------------------
function buildPrompt(userText) {
  const classMode = (schoolMode && schoolMode.value) || "general";
  const sub = (subject && subject.value) || "general";

  const baseRole = `You are "Spidey Teacher" ‚Äî a warm, playful, and patient teacher who explains things clearly. Use age-appropriate vocabulary and tone.`;

  const gradeConfig = {
    general: {
      label: "General audience",
      tone: "friendly and clear",
      vocab: "plain",
      sentenceAdvice: "short sentences; avoid technical jargon",
      lengthLimit: "Keep answers concise.",
      examplesInstruction: "Use a simple example if helpful.",
      checkQuestion: "Ask one brief question at the end to check understanding."
    },
    class3: {
      label: "Class 3 (about 8 years old)",
      tone: "very friendly, playful, encouraging",
      vocab: "very simple; words a child in class 3 knows",
      sentenceAdvice: "use short sentences and simple phrases (1‚Äì2 short sentences per idea)",
      lengthLimit: "Keep responses very short ‚Äî about 30‚Äì70 words (one short paragraph).",
      examplesInstruction: "Use a relatable analogy (toys, pets, school) and one short example.",
      checkQuestion: "Finish with a single simple question (yes/no or one-word answer)."
    },
    class7: {
      label: "Class 7 (about 13 years old)",
      tone: "friendly, slightly more explanatory",
      vocab: "everyday vocabulary with a few new words explained",
      sentenceAdvice: "short paragraphs (2‚Äì3 sentences each); introduce one new idea at a time",
      lengthLimit: "Keep responses concise ‚Äî about 80‚Äì140 words (1‚Äì2 short paragraphs).",
      examplesInstruction: "Use a clear example and one analogy (everyday life or simple science).",
      checkQuestion: "Ask one quick comprehension question (multiple-choice or short answer)."
    },
    class10: {
      label: "Class 10 (about 15‚Äì16 years old)",
      tone: "clear, slightly formal but friendly, explanatory",
      vocab: "use proper subject vocabulary but define terms briefly",
      sentenceAdvice: "use 2‚Äì3 short paragraphs; allow slightly longer sentences",
      lengthLimit: "Keep responses focused ‚Äî about 120‚Äì250 words as needed.",
      examplesInstruction: "Give an example or small step-by-step explanation; show one mini-analogy.",
      checkQuestion: "Ask one short comprehension or application question."
    }
  };

  const cfg = gradeConfig[classMode] || gradeConfig.general;
  const subjectHint = (sub && sub !== "general") ? `Focus on the subject: ${sub}.` : "";

  const formattingGuidance = [
    "Do not use code blocks.",
    "If you use bullet points, keep them to 3 or fewer short bullets.",
    "Avoid raw Markdown symbols in the visible text (no ** or ##).",
    "Do not ask for additional follow-ups unless asked‚Äîkeep the answer self-contained.",
    "Use friendly punctuation and short sentences for younger grades."
  ].join(" ");

  const prompt = [
    baseRole,
    `Grade instructions: ${cfg.label}. Tone: ${cfg.tone}. Vocabulary: ${cfg.vocab}. ${cfg.sentenceAdvice}. ${cfg.lengthLimit}`,
    subjectHint,
    `Instructions for examples: ${cfg.examplesInstruction}. ${cfg.checkQuestion}`,
    `Formatting rules: ${formattingGuidance}`,
    "\nNow answer the user's question below. Keep the answer within the length guidance for this grade and end with the short comprehension question as requested.",
    `\nUser question: ${userText}`
  ].filter(Boolean).join("\n\n");

  return prompt;
}

// -----------------------------------------------------------
// Generation params by class (temperature, max_tokens, top_p)
// -----------------------------------------------------------
function getGenerationParamsForClass() {
  const classMode = (schoolMode && schoolMode.value) || "general";
  const mapping = {
    general:  { temperature: 0.25, max_tokens: 220, top_p: 0.9 },
    class3:   { temperature: 0.20, max_tokens: 120, top_p: 0.9 },
    class7:   { temperature: 0.25, max_tokens: 220, top_p: 0.9 },
    class10:  { temperature: 0.30, max_tokens: 350, top_p: 0.9 }
  };
  return mapping[classMode] || mapping.general;
}

// -----------------------------------------------------------
// SEND MESSAGE TO BACKEND (with markdown rendering + TTS coordination)
// -----------------------------------------------------------
async function askBackend(text) {
  try {
    if (!text || !text.trim()) return;
    statusEl && (statusEl.textContent = "Thinking...");
    avatarStartTalking && avatarStartTalking(); // small visual while waiting for response

    // generation params
    const genParams = getGenerationParamsForClass();
    const payload = {
      prompt: buildPrompt(text),
      temperature: genParams.temperature,
      max_tokens: genParams.max_tokens,
      top_p: genParams.top_p
    };

    const response = await fetch(API_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      avatarStopTalking && avatarStopTalking();
      if (replyBox) replyBox.textContent = "Error from server.";
      log("‚ùå Error from backend: " + response.status);
      statusEl && (statusEl.textContent = "Idle");
      return;
    }

    const data = await response.json();
    avatarStopTalking && avatarStopTalking();

    const reply = data.reply ?? "No reply.";

    // Render markdown to UI and get cleaned text for TTS
    const speakable = renderReplyMarkdown(reply);
    // store speakable so resume can restart if needed
    lastSpokenText = speakable || lastSpokenText;
    log("AI replied.");

    // Auto-scroll conversation to show reply
    scrollConversationToBottom(true);

    // Ensure recognition is off while we speak
    try { stopListening(); } catch (e) { /* ignore */ }
    isListening = false;

    // Start TTS using global speakText (our fallback exists if speech.js doesn't provide one)
    if (typeof window.speakText === "function" && speakable) {
      // Ensure pause/resume buttons are in correct state
      setPauseResumeUI(false);
      isTtsPaused = false;
      statusEl && (statusEl.textContent = "Reading...");
      // Dispatch start event for avatar as well (speakText implementation will dispatch too)
      document.dispatchEvent(new CustomEvent("avatarTalkStart"));

      try {
        window.speakText(speakable);
      } catch (e) {
        console.warn("Error while calling speakText:", e);
        statusEl && (statusEl.textContent = "Idle");
      }
    } else {
      console.warn("TTS function window.speakText not found or nothing to speak.");
      statusEl && (statusEl.textContent = "Idle");
    }
  } catch (err) {
    if (replyBox) replyBox.textContent = "Network error.";
    log("‚ùå Network error");
    console.error(err);
    statusEl && (statusEl.textContent = "Idle");
  }
}

// -----------------------------------------------------------
// onUserSpeech - callback used for recognition result
// -----------------------------------------------------------
async function onUserSpeech(text) {
  if (!transcriptBox || !replyBox) {
    console.log("User said:", text);
  } else {
    transcriptBox.style.display = "block";
    transcriptBox.textContent = text;
  }
  log("User said: " + text);
  await askBackend(text);
}

// -----------------------------------------------------------
// MIC BUTTON ‚Äî START/STOP LISTENING (single handler)
// -----------------------------------------------------------
if (micBtn) {
  micBtn.addEventListener("click", () => {
    if (!isListening) {
      // stop any TTS so listening can start immediately
      stopTTS();

      // user requests continuous behavior (we'll resume after replies)
      userWantedContinuous = true;

      isListening = true;
      micBtn.textContent = "üõë Stop Listening";
      statusEl && (statusEl.textContent = "Listening...");

      startListening(onUserSpeech, { continuous: false });
    } else {
      userWantedContinuous = false;
      isListening = false;
      micBtn.textContent = "üé§ Start Listening";
      stopListening();
      statusEl && (statusEl.textContent = "Idle");
    }
  });
}

// -----------------------------------------------------------
// TEST BUTTON ‚Äî QUICK STATIC REQUEST
// -----------------------------------------------------------
if (testBtn) {
  testBtn.addEventListener("click", async () => {
    if (transcriptBox) {
      transcriptBox.style.display = "block";
      transcriptBox.textContent = "Hello!";
    }
    await askBackend("Hello! Introduce yourself.");
  });
}

// -----------------------------------------------------------
// CLEAR BUTTON
// -----------------------------------------------------------
if (clearBtn) {
  clearBtn.addEventListener("click", () => {
    if (transcriptBox) transcriptBox.textContent = "";
    if (replyBox) replyBox.textContent = "";
    log("Cleared screen.");
    if (conversationScroll) conversationScroll.scrollTop = 0;
  });
}

// -----------------------------------------------------------
// DEMO LESSON BUTTON
// -----------------------------------------------------------
if (demoLessonBtn) {
  demoLessonBtn.addEventListener("click", async () => {
    await askBackend("Teach me a 30-second mini lesson suitable for a child.");
  });
}

// -----------------------------------------------------------
// QUICK-SELECT CLASS / SUBJECT BUTTONS (UI wiring)
// -----------------------------------------------------------
function clearActiveClassButtons() {
  classButtons.forEach(b => b.classList.remove("active"));
}
function clearActiveSubjectButtons() {
  subjectButtons.forEach(b => b.classList.remove("active"));
}

classButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const cls = btn.dataset.class;
    if (!cls) return;
    if (schoolMode) schoolMode.value = cls;
    clearActiveClassButtons();
    btn.classList.add("active");
    log("Class set to " + cls);
  });
});

subjectButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const sub = btn.dataset.sub;
    if (!sub) return;
    if (subject) subject.value = sub;
    clearActiveSubjectButtons();
    btn.classList.add("active");
    log("Subject set to " + sub);
  });
});

// Keep selects in sync with quick buttons
if (schoolMode) {
  schoolMode.addEventListener("change", () => {
    clearActiveClassButtons();
    const cls = schoolMode.value;
    classButtons.forEach(b => { if (b.dataset.class === cls) b.classList.add("active"); });
  });
}
if (subject) {
  subject.addEventListener("change", () => {
    clearActiveSubjectButtons();
    const s = subject.value;
    subjectButtons.forEach(b => { if (b.dataset.sub === s) b.classList.add("active"); });
  });
}

// -----------------------------------------------------------
// CHAT INPUT wiring (sendBtn + Enter key)
// -----------------------------------------------------------
if (sendBtn && chatInput) {
  sendBtn.addEventListener("click", async () => {
    const v = chatInput.value.trim();
    if (!v) return;
    if (transcriptBox) {
      transcriptBox.style.display = "block";
      transcriptBox.textContent = v;
    }
    chatInput.value = "";
    log("Typed: " + v);
    await askBackend(v);
  });

  chatInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      sendBtn.click();
    }
  });
}

// -----------------------------------------------------------
// conversationScroll auto-scroll helper: show latest when replies arrive
// Also ensure top small transcript is visible by ensuring scroll padding.
// -----------------------------------------------------------
if (conversationScroll) {
  setTimeout(() => scrollConversationToBottom(false), 200);
  try {
    const obs = new MutationObserver(() => scrollConversationToBottom(true));
    obs.observe(replyBox || document.body, { childList: true, subtree: true, characterData: true });
  } catch (e) { /* ignore */ }
}

// -----------------------------------------------------------
// SpeechSynthesisUtterance events may not fire if voices not loaded immediately.
// Add a safety: update lastUtterance/lastSpokenText when window.speakText called above.
// -----------------------------------------------------------

// Keep speaking state synced with utterance events, and ensure UI toggles correctly
document.addEventListener("avatarTalkStart", () => {
  isSpeaking = true;
  statusEl && (statusEl.textContent = "Reading...");
  if (pauseTtsBtn) pauseTtsBtn.style.display = "inline-block";
  if (resumeTtsBtn) resumeTtsBtn.style.display = "none";
});

document.addEventListener("avatarTalkStop", () => {
  isSpeaking = false;
  // if user wanted continuous listening, ask to resume after a small delay (handled by askBackend when TTS end)
  if (!userWantedContinuous) {
    statusEl && (statusEl.textContent = "Idle");
  }
});

// -----------------------------------------------------------
// INITIAL LOG
// -----------------------------------------------------------
log("Frontend loaded. Ready.");
if (pauseTtsBtn) pauseTtsBtn.style.display = "inline-block";
if (resumeTtsBtn) resumeTtsBtn.style.display = "none";
if (statusEl) statusEl.textContent = "Idle";







‚Äî---------------------------------------------------------------------------------------------------


2 index html

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Speaking Avatar ‚Äî MVP</title>

  <!-- Optional: Kid-friendly Google Fonts (recommended) -->
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Poppins:wght@500;700&display=swap" rel="stylesheet">

  <!-- Link to your stylesheet -->
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="frame">

    <!-- LEFT: Avatar / Canvas -->
    <div class="panel left" role="main" aria-label="Avatar area and controls">
      <h1>Speaking Avatar ‚Äî MVP</h1>

      <!-- Avatar / Three.js canvas container -->
      <div id="canvas-container" aria-label="3D avatar area" class="panel"></div>

      <!-- Controls row -->
      <div class="controls" role="toolbar" aria-label="Voice controls">
        <button id="micBtn" title="Start or stop listening">üé§ Start Listening</button>

        <!-- Pause / resume / stop for TTS -->
        <button id="pauseTtsBtn" class="secondary" title="Pause reading">‚è∏ Pause TTS</button>
        <button id="resumeTtsBtn" class="secondary" style="display:none" title="Resume reading">‚ñ∂ Resume TTS</button>
        <button id="stopTtsBtn" class="secondary" title="Stop reading">‚èπ Stop TTS</button>

        <!-- Quick test -->
        <button id="testBtn" class="secondary" title="Send a test message">üß™ Test Chat</button>

        <div id="status" class="meta" role="status" aria-live="polite" style="margin-left:10px">Idle</div>
      </div>

      <footer class="small" aria-hidden="false">
        Mic uses Web Speech API. Audio uses browser TTS (speechSynthesis). Avatar uses Three.js GLB model from <code>/assets/avatar.glb</code>.
      </footer>
    </div>

    <!-- RIGHT: Conversation / Mode / Quick selects -->
    <div class="panel right" role="complementary" aria-label="Conversation and settings">

      <h1>Conversation</h1>

      <!-- Optional typed chat input (press Send or wire Enter -> askBackend in JS) -->
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <input id="chatInput" type="text" placeholder="Type a question for Spidey Teacher..." aria-label="Type your question" style="flex:1;padding:12px;border-radius:16px;border:2px solid #e0e0e0;font-size:15px">
        <button id="sendBtn" class="secondary" title="Send typed question">Send</button>
      </div>
      <!-- Note: To make the typed input actually send to the backend, add a small JS snippet that calls your
           askBackend(chatInput.value) function. Because app.js is an ES module, wire send handling inside that module. -->

      <!-- SCROLLABLE AREA (conversation history) -->
      <div id="conversationScroll" class="scroll-area" role="region" aria-label="Conversation history">
        <!-- Top small transcript area (shows what user said or typed briefly) -->
        <div id="transcript" class="bubble user" style="display:none" aria-hidden="true"></div>

        <!-- AI reply area (rendered markdown) -->
        <div id="reply" class="bubble" role="article" aria-live="polite"></div>
      </div>
      <!-- /SCROLLABLE AREA -->

      <!-- Quick class selector buttons -->
      <div style="margin-top:6px">
        <div class="small" style="margin-bottom:8px"><strong>Quick Class</strong></div>
        <div id="classButtons" style="display:flex;gap:8px;flex-wrap:wrap" role="group" aria-label="Quick class select">
          <button class="class-btn secondary" data-class="class3" aria-pressed="false">Class 3</button>
          <button class="class-btn secondary" data-class="class7" aria-pressed="false">Class 7</button>
          <button class="class-btn secondary" data-class="class10" aria-pressed="false">Class 10</button>
        </div>
      </div>

      <!-- Quick subject selector buttons -->
      <div style="margin-top:8px">
        <div class="small" style="margin-bottom:8px"><strong>Quick Subject</strong></div>
        <div id="subjectButtons" style="display:flex;gap:8px;flex-wrap:wrap" role="group" aria-label="Quick subject select">
          <button class="subject-btn secondary" data-sub="general" aria-pressed="false">General</button>
          <button class="subject-btn secondary" data-sub="math" aria-pressed="false">Math</button>
          <button class="subject-btn secondary" data-sub="english" aria-pressed="false">English</button>
          <button class="subject-btn secondary" data-sub="evs" aria-pressed="false">EVS</button>
          <button class="subject-btn secondary" data-sub="gk" aria-pressed="false">GK</button>
        </div>
      </div>

      <!-- Mode & Subject selects (these drive prompts) -->
      <div style="margin-top:12px">
        <div class="small" style="margin-bottom:6px"><strong>Mode</strong></div>
        <select id="schoolMode" class="small" aria-label="Choose class / mode">
          <option value="general">General (Default)</option>
          <option value="class3">Class 3 (8 yrs)</option>
          <option value="class7">Class 7 (13 yrs)</option>
          <option value="class10">Class 10 (15 yrs)</option>
        </select>
      </div>

      <div style="margin-top:12px">
        <div class="small" style="margin-bottom:6px"><strong>Subject</strong></div>
        <select id="subject" class="small" aria-label="Choose subject">
          <option value="general">General</option>
          <option value="math">Mathematics</option>
          <option value="english">English</option>
          <option value="evs">EVS</option>
          <option value="gk">General Knowledge</option>
        </select>
      </div>

      <!-- Clear + Demo buttons -->
      <div style="margin-top:12px;display:flex;gap:8px">
        <button id="clearBtn" class="secondary" style="flex:1">Clear</button>
        <button id="demoLessonBtn" class="secondary" style="flex:1">Load Demo Lesson</button>
      </div>

      <!-- Status / log -->
      <div style="margin-top:12px" class="small" aria-live="polite">
        <strong>Status</strong>
        <div id="log" style="margin-top:8px;color:var(--muted);min-height:60px;font-size:13px"></div>
      </div>
    </div>
  </div>

  <!-- Markdown + sanitizer (CDN) - MUST load before your app bundle -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

  <!-- App scripts (ES module) -->
  <script type="module" src="/src/app.js"></script>

  <!--
    Optional: If you want the typed input to work immediately without editing app.js,
    add this snippet inside an ES module that imports askBackend from your module.
    Because askBackend is defined inside /src/app.js (not exported), it's safer to
    wire this inside your app.js:

    // inside /src/app.js (near the end)
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    sendBtn.addEventListener('click', async () => {
      const v = chatInput.value.trim();
      if (v) { await askBackend(v); chatInput.value = ''; }
    });
    chatInput.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') { sendBtn.click(); }
    });
  -->
</body>
</html>


























‚Äî-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
‚Äî-----------------------------
‚Äî-----------------

3 style csss

/* ========================================================================== 
   KID-SCHOOL-LEARNING THEME 2025 ‚Äì SUPER FRIENDLY EDITION
   Adapted to the Speaking Avatar ‚Äî MVP HTML (keeps IDs/classes used by app.js)
   ========================================================================== */

/* ----------------------
   GOOGLE FONTS (optional)
   Add this into <head> of index.html for the full look:
   <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Fredoka+One&family=Poppins:wght@500;700&display=swap" rel="stylesheet">
   ---------------------- */

/* ----------------------
   THEME VARIABLES ‚Äì HAPPY & ACCESSIBLE
   ---------------------- */
:root {
  /* Background gradient ‚Äì sunny sky to green grass */
  --bg-start: #87CEEB;      /* sky blue */
  --bg-end:   #98FB98;      /* minty grass */

  /* Panel & glass ‚Äì bright white with soft opacity; tuned to keep readabilty */
  --glass: rgba(255, 255, 255, 0.92);
  --glass-2: rgba(255, 255, 255, 0.96);
  --panel-bg: rgba(255, 255, 255, 0.95);

  /* Main happy colors */
  --accent: #FF6B6B;        /* coral red ‚Äì buttons & highlights */
  --blue:   #4DABF7;        /* sky blue */
  --green:  #51CF66;        /* success green */
  --yellow: #FFD43B;        /* sun yellow */
  --purple: #DA77F2;        /* fun purple */
  --pink:   #FFA8E2;

  /* Text ‚Äì super high contrast */
  --text: #212529;
  --text-light: #495057;
  --muted: #868e96;

  /* Bubbles */
  --user-bubble: rgba(77, 171, 247, 0.25);      /* light blue */
  --ai-bubble:   rgba(255, 107, 107, 0.20);     /* light coral */

  /* Borders & shadows */
  --border: rgba(0, 0, 0, 0.08);
  --shadow: 0 12px 32px rgba(0, 0, 0, 0.12);

  /* Layout */
  --panel-radius: 28px;     /* super round = kid friendly */
  --gap: 24px;
  --frame-width: 1100px;
  --right-panel-max-offset: 100px;
}

/* ----------------------
   GLOBAL
   ---------------------- */
* { box-sizing: border-box; }
html, body { height: 100%; overflow-x: hidden; }

body {
  margin: 0;
  font-family: 'Poppins', 'Comic Neue', system-ui, sans-serif;
  background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
  color: var(--text);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 32px 16px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
}

/* ----------------------
   LAYOUT
   ---------------------- */
.frame {
  width: var(--frame-width);
  max-width: 100%;
  display: flex;
  gap: var(--gap);
  align-items: stretch;
}

.panel {
  background: var(--panel-bg);
  border-radius: var(--panel-radius);
  padding: 20px;
  box-shadow: var(--shadow);
  border: 3px solid rgba(255, 255, 255, 0.8);
  backdrop-filter: blur(10px);
}

/* Left column (avatar / canvas) */
.left {
  width: 660px;
  max-width: 100%;
  display: flex;
  flex-direction: column;
  gap: var(--gap);
}

/* Right column (conversation / controls)
   NOTE: updated to allow the panel itself to scroll if internal content grows,
   while keeping the conversation .scroll-area scrollable internally.
*/
.panel.right {
  width: 420px;
  max-width: 100%;
  min-width: 320px;

  /* keep column layout */
  display: flex;
  flex-direction: column;
  gap: 16px;

  /* keep a viewport-aware constraint but allow the panel itself to scroll */
  max-height: calc(100vh - var(--right-panel-max-offset));
  overflow-y: auto !important;
  -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
}

/* ----------------------
   SCROLL AREA (conversation history)
   ---------------------- */
.scroll-area {
  /* take remaining vertical space inside right panel and stay scrollable */
  flex: 1 1 auto;
  overflow-y: auto !important;
  padding: 12px 8px 12px 0;
  min-height: 240px;
  border-radius: 20px;
  box-sizing: border-box;
  /* a safe max-height that respects viewport and header/padding sizes */
  max-height: calc(100vh - 220px); /* adjust 220px if your header/footer size differs */
}

/* ----------------------
   BUBBLES ‚Äì SUPER CUTE
   ---------------------- */
.bubble {
  padding: 16px 20px;
  border-radius: 24px;
  margin-bottom: 14px;
  font-size: 16px;
  line-height: 1.6;
  max-width: 92%;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
  position: relative;
  word-break: break-word;
}

/* User bubble (right aligned) */
.bubble.user {
  background: var(--user-bubble);
  border: 3px solid var(--blue);
  margin-left: auto;
  color: var(--text);
}

/* AI bubble (left aligned) */
.bubble:not(.user) {
  background: var(--ai-bubble);
  border: 3px solid var(--accent);
  margin-right: auto;
  color: var(--text);
}

/* Sweet sparkle for AI replies */
.bubble:not(.user)::before {
  content: "‚ú® ";
  font-size: 18px;
}

/* ----------------------
   BUTTONS ‚Äì CANDY STYLE
   ---------------------- */
button {
  padding: 14px 20px;
  border: none;
  border-radius: 50px;
  font-weight: 700;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
}

button {
  background: var(--accent);
  color: white;
}

button:hover {
  transform: translateY(-4px) scale(1.05);
  box-shadow: 0 12px 28px rgba(255, 107, 107, 0.4);
}

button:active {
  transform: translateY(0);
}

button.secondary {
  background: #f1f3f5;
  color: var(--text);
  border: 2px solid #dee2e6;
}

/* Quick select pills */
.class-btn, .subject-btn {
  padding: 12px 18px;
  border-radius: 50px;
  background: white;
  border: 3px solid #e0e0e0;
  font-weight: 700;
  color: var(--text-light);
  transition: all 0.2s;
}

/* Active pill */
.class-btn.active, .subject-btn.active {
  background: var(--yellow);
  border-color: #fcc419;
  color: #333;
  transform: scale(1.1);
}

/* ----------------------
   SELECTS
   ---------------------- */
select {
  padding: 14px;
  border-radius: 20px;
  background: white;
  border: 3px solid #e0e0e0;
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
}

/* ----------------------
   REPLY & TRANSCRIPT
   ---------------------- */
#reply, #transcript {
  padding: 20px;
  border-radius: 24px;
  background: white;
  border: 3px solid #e0e0e0;
  font-size: 16px;
  min-height: 80px;
  box-shadow: inset 0 4px 10px rgba(0,0,0,0.05);
}

/* Status log */
#log {
  color: var(--muted);
  font-size: 14px;
  padding: 12px;
  background: rgba(0,0,0,0.03);
  border-radius: 16px;
}

/* ----------------------
   SCROLLBAR ‚Äì KID FRIENDLY
   ---------------------- */
.scroll-area::-webkit-scrollbar {
  width: 12px;
}
.scroll-area::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.05);
  border-radius: 10px;
}
.scroll-area::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 10px;
  border: 3px solid white;
}

/* Ensure right-panel scrollbar is visible on light theme if panel itself scrolls */
.panel.right::-webkit-scrollbar { width: 12px; }
.panel.right::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.12); border-radius: 8px; border: 3px solid white; }

/* ----------------------
   Responsive ‚Äì TABLETS & PHONES
   ---------------------- */
@media (max-width: 900px) {
  .frame { flex-direction: column; padding: 16px; gap: 20px; }
  .left, .panel.right { width: 100%; }
  .panel.right { max-height: none; overflow: visible; }
  .scroll-area { max-height: 400px; }
  #canvas-container { height: 380px; border-radius: 28px; overflow: hidden; }
}

/* ----------------------
   REDUCED MOTION
   ---------------------- */
@media (prefers-reduced-motion: reduce) {
  * { animation: none !important; transition: none !important; }
}

/* ----------------------
   EXTRA CUTENESS (heading style)
   ---------------------- */
h1, .panel.right > h1 {
  font-family: 'Fredoka One', cursive;
  color: var(--accent);
  font-size: 28px;
  text-align: center;
  margin: 0 0 16px;
  text-shadow: 2px 2px 0 rgba(255,107,107,0.2);
}

/* ----------------------
   Quick-select wrapping helpers
   ---------------------- */
#classButtons, #subjectButtons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

/* ----------------------
   NOTES:
   - This file expects the same HTML structure we used already:
     .frame > .panel.left, .panel.right
     inside .panel.right: .scroll-area containing #transcript and #reply
     control buttons keep IDs: #micBtn, #pauseTtsBtn, #resumeTtsBtn, #stopTtsBtn, #testBtn
     quick-selects use .class-btn and .subject-btn
   - The right-panel scrolling behavior was adjusted so the panel itself can scroll if the content grows
     and the .scroll-area still scrolls internally for messages.
   - If you want the panel not to scroll and only the scroll-area to scroll, set .panel.right { overflow-y: hidden; } 
     and keep .scroll-area with overflow-y:auto.
   - Adjust `max-height: calc(100vh - 220px)` in .scroll-area if your header/footer sizes differ.
   ---------------------- */


4.threejs-avatar.js:
// frontend/src/threejs-avatar.js
// SPIDEY MASK MVP ‚Äî robust, defensive, mouth open/close animation
// Safe against model load timing and avoids uncaught null dereferences.

import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

let scene, camera, renderer;
let avatar = null;          // root of loaded GLB
let avatarReady = false;    // set true after model is fully prepared
let isTalking = false;
const clock = new THREE.Clock();
let cached = {};            // cache commonly used nodes (mouth, head, etc.)

// container may not exist in DOM yet ‚Äî guard for that
const container = document.getElementById("canvas-container") || (function createFallback() {
  const el = document.createElement("div");
  el.id = "canvas-container";
  el.style.width = "640px";
  el.style.height = "480px";
  el.style.background = "#000";
  document.body.prepend(el);
  console.warn("canvas-container missing ‚Äî created fallback container.");
  return el;
})();

function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setClearColor(0x000000, 0); // transparent
  container.innerHTML = ""; // clear any content (safe)
  container.appendChild(renderer.domElement);

  // Scene & Camera
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(25, container.clientWidth / container.clientHeight, 0.1, 100);
  camera.position.set(0, 0, 5);

  // Lighting
  const hemi = new THREE.HemisphereLight(0xff3366, 0x441144, 1.4);
  scene.add(hemi);
  const rim = new THREE.DirectionalLight(0xff0000, 0.6);
  rim.position.set(0, 0, -5);
  scene.add(rim);

  // small ambient to soften
  const amb = new THREE.AmbientLight(0x222222, 0.8);
  scene.add(amb);

  // load model
  loadMask();

  // start animation loop (guarded)
  animate();

  // responsive
  window.addEventListener("resize", () => {
    if (!camera || !renderer) return;
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
}

function loadMask() {
  const loader = new GLTFLoader();

  loader.load(
    "/assets/avatar.glb",
    (gltf) => {
      try {
        if (avatar) scene.remove(avatar);
        avatar = gltf.scene || gltf.scenes && gltf.scenes[0] || null;
        if (!avatar) {
          console.warn("GLTF loaded but no scene found.");
          return;
        }

        // scale/position/rotation tuned for this project
        avatar.scale.set(7, 7, 7);
        avatar.position.set(0, 0.1, 0);
        avatar.rotation.y = Math.PI;

        // optional: center geometry if necessary
        // compute bounding box and center if model is off-center
        try {
          const box = new THREE.Box3().setFromObject(avatar);
          const center = box.getCenter(new THREE.Vector3());
          avatar.position.sub(center.multiplyScalar(1)); // recenter if needed
        } catch (e) { /* ignore bbox issues */ }

        scene.add(avatar);

        // traverse once and cache nodes of interest (names are guessed; log for debug)
        gltf.scene.traverse((node) => {
          if (!node || !node.name) return;
          const name = node.name.toLowerCase();
          // find jaw/mouth-like nodes
          if (!cached.mouth && (name.includes("jaw") || name.includes("mouth") || name.includes("lip") || name.includes("lower"))) {
            cached.mouth = node;
          }
          // head or skull name
          if (!cached.head && (name.includes("head") || name.includes("skull"))) {
            cached.head = node;
          }
        });

        // fallback: if mouth not found, try to find a mesh with "lower" geometry or first skinned mesh
        if (!cached.mouth) {
          let fallback = null;
          avatar.traverse((n) => {
            if (!fallback && n.isMesh && n.name && /lower|jaw|mouth/i.test(n.name)) fallback = n;
          });
          if (!fallback) {
            // pick first mesh as a last resort (won't break; we guard usage)
            avatar.traverse((n) => { if (!fallback && n.isMesh) fallback = n; });
          }
          cached.mouth = fallback || null;
        }

        // mark ready
        avatarReady = true;
        console.log("üï∑Ô∏è Spidey Mask Loaded & Ready!", { cached });
      } catch (err) {
        console.error("Error in GLTF load callback:", err);
      }
    },
    (xhr) => {
      // progress (optional)
      // console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
    },
    (err) => {
      console.error("Failed to load GLB:", err);
    }
  );
}

// exported functions for app to notify avatar about speaking state
export function avatarStartTalking() {
  isTalking = true;
  // let other parts of app know
  try { document.dispatchEvent(new CustomEvent("avatarTalkStart")); } catch(e) {}
}

export function avatarStopTalking() {
  isTalking = false;
  try { document.dispatchEvent(new CustomEvent("avatarTalkStop")); } catch(e) {}
}

// safe animate loop ‚Äî will not crash if avatar or cached nodes are missing
function animate() {
  requestAnimationFrame(animate);

  try {
    // Render something even if avatar not yet ready
    if (!avatarReady || !avatar) {
      if (renderer && scene && camera) renderer.render(scene, camera);
      return;
    }

    const t = clock.getElapsedTime();

    // Basic breathing / bobbing when speaking
    if (isTalking) {
      // bob up/down and slight rotations
      if (avatar) {
        avatar.position.y = 0.1 + Math.sin(t * 3.0) * 0.12; // faster bob
        avatar.rotation.x = Math.sin(t * 1.8) * 0.06;
        avatar.rotation.z = Math.sin(t * 1.2) * 0.03;
      }

      // mouth "open/close" animation ‚Äî use cached.mouth if it's transformable
      if (cached.mouth && cached.mouth.position) {
        // if it's a bone or object, move it slightly
        cached.mouth.position.y = (cached.mouth.position.y || 0) + Math.abs(Math.sin(t * 8.0)) * 0.02;
        cached.mouth.scale && (cached.mouth.scale.y = 1 + Math.abs(Math.sin(t * 8.0)) * 0.08);
      } else if (avatar && avatar.scale) {
        // fallback: scale root Y a little for a fake mouth movement (non-destructive)
        avatar.scale.y = 7 + Math.abs(Math.sin(t * 8.0)) * 0.5;
      }

    } else {
      // smooth return to rest state (guard node existence)
      if (avatar && avatar.position) {
        avatar.position.y += (0.1 - avatar.position.y) * 0.08;
        avatar.rotation.x *= 0.92;
        avatar.rotation.z *= 0.92;
        avatar.scale.y += (7 - avatar.scale.y) * 0.08;
      }
      if (cached.mouth && cached.mouth.position) {
        // gently restore mouth position/scale if we modified it
        cached.mouth.position.y += ((cached.mouth._baseY || 0) - (cached.mouth.position.y || 0)) * 0.08;
        if (cached.mouth.scale) cached.mouth.scale.y += (1 - cached.mouth.scale.y) * 0.08;
      }
    }

    // render safely
    if (renderer && scene && camera) renderer.render(scene, camera);
  } catch (err) {
    // catch everything in the loop to avoid breaking other modules
    console.error("Avatar animate error (caught):", err);
  }
}

// initialize safely (guard errors)
try {
  init();
} catch (e) {
  console.error("threejs-avatar init failed:", e);
}






